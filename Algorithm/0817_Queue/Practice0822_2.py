"""
[Fig. 1] 과 같이 N x N 크기 정사각형 모양의 지형을 가진 행성이 있다.
N x N 크기 지형의 각 칸은 농지와 산 중 하나이다. ( 빈 칸은 농지를 의미하고 산 모양의 칸은 산을 의미한다. )

농지에 씨를 심고 1 일이 지나면 싹이 난다.
그 농지에 대해서 1 번째로 싹이 나는 경우, 싹이 난 후 4 ( = 3 + 1 ) 일 이후에 곡식이 열린다.
그 농지에 대해서 K 번째로 싹이 나는 경우, 싹이 난 후 3 + K 일 이후에 곡식이 열린다. ( K 는 1 이상의 정수 )
지구인들은 이 행성에 로봇 “개척자”를 보내어 곡물을 수확하고자 한다.

로봇은 매일 오전과 오후로 나눠서 다음과 같이 동작한다.
    1) 로봇은 오전에 현재 위치에서 아래의 작업 중 하나를 수행한다.
        - 현재 농지가 빈 농지이고 로봇이 다음 농지로 이동할 수 있는 경우 씨를 심는다.
        - 현재 농지가 빈 농지이고, 로봇이 다음 농지로 이동할 수 없을 경우 아무것도 하지 않고 현재 위치에서 머무른다.
        - 현재 농지에 곡식이 열린 경우 수확을 한다. 수확을 하면 농지는 빈 농지가 된다.
    2) 로봇은 오후에 로봇이 바라보는 방향의 오른쪽, 앞쪽, 왼쪽, 뒤쪽 이웃하는 곳 중, 이동 가능한 곳으로 이동한다.
        - 이동 가능한 곳은 빈 농지, 또는 곡식이 열린 농지이다. 산이거나 싹이 나는 농지인 경우 이동이 불가능하다.
        - 만약, 이동 가능한 곳이 여러 개인 경우, 로봇의 오른쪽, 앞쪽, 왼쪽, 뒤쪽의 순서로 가장 먼저인 이동 가능한 곳으로 이동한다.
        - 만약 이동 가능한 곳이 없는 경우 로봇은 이동하지 않고 현재 위치에 머무른다.
    3) 다음 날이 되면 과정 1) ~ 2) 를 반복한다.

로봇 “개척자” 는 행성에 도착한 날로부터 M 일 까지 동작할 수 있다.
지구인들은 M 일 동안 곡식을 가장 많이 수확할 수 있는 시작 위치와 방향을 알고 싶어한다.

행성의 지형 정보가 주어졌을 때, M 일 동안 “개척자” 로봇이 곡식을 가장 많이 수확할 수 있는 시작 위치와 방향을 찾고,
이때 수확 횟수를 출력하는 프로그램을 작성하라.

[제약사항]
    1. 지형의 한 변의 길이 N 은 6 이상 9 이하의 정수이다. ( 6 ≤ N ≤ 9 )
    2. 로봇이 동작하는 일 수 M 은 10 이상 50 이하의 정수이다. ( 10 ≤ M ≤ 50 )
    3. 지형의 테두리는 언제나 산이다.
    4. 지형 정보에서 0 은 농지, 1 은 산을 의미한다.
    5. 주어지는 지형에는 반드시 농지가 1 개 이상 있다.
    6. 로봇의 시작점은 언제나 농지이어야 한다. 산에서 시작할 수 없다.

입력
입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,
그 다음 줄부터 T 개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 지형의 한 변의 길이 N, 로봇이 동작 가능한 일 수 M 이 주어진다.
다음 N 개의 줄에는 지형 정보가 주어진다. 농지는 0, 산은 1 로 주어진다.

출력
테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )
출력해야 할 정답은, 로봇 "개척자" 의 최대 수확 횟수이다.
"""
import sys
sys.stdin = open("input.txt", "r")
from copy import deepcopy


def DFS(y, x, day, d, cnt):
    if day > M:
        global result
        result = max(result, cnt)
        return
    for i in range(4):
        # 오른쪽, 위, 왼쪽, 아래 순서로 다음 방향 탐색
        ny, nx = y + move_direction[(i + d) % 4][0], x + move_direction[(i + d) % 4][1]
        # 다음 방향 탐색 시 머리 방향
        nd = (i + d + 3) % 4

        # 현재 농지에 곡식이 열린 경우(arr[y][x] == 2)
        if 0 <= ny < N and 0 <= nx < N and temp_arr[y][x] == 2:
            # 이동할 수 있는 경우
            if temp_arr[ny][nx] == 0:
                # 오전/ 수확
                cnt += 1
                temp_arr[y][x] = 0
                plant[(y, x)][0] = M
                # 오후/ 이동
                DFS(ny, nx, day + 1, nd, cnt)
                return
            # 이동할 수 있는 경우
            elif temp_arr[ny][nx] == 2 and (plant[(ny, nx)][0] + plant[(ny, nx)][1] < day - 4):
                # 오전/ 수확
                cnt += 1
                temp_arr[y][x] = 0
                plant[(y, x)][0] = M
                # 오후/ 이동
                DFS(ny, nx, day + 1, nd, cnt)
                return

        # 현재 빈농지이고(arr[y][x] == 0),
        if 0 <= ny < N and 0 <= nx < N and temp_arr[y][x] == 0:
            # 이동할 수 있는 경우
            if temp_arr[ny][nx] == 0:
                # 오전/ 현재 위치에 씨앗을 심음
                temp_arr[y][x] = 2
                # 심는 씨앗에 심은 날짜와, 그 지역에 심어진 횟수를 기록한다.
                if (y, x) not in plant.keys():
                    plant[(y, x)] = [day, 0]
                elif (y, x) in plant.keys():
                    plant[(y, x)][0] = day
                    plant[(y, x)][1] += 1
                # 오후/ 이동
                DFS(ny, nx, day + 1, nd, cnt)
                return
            # 이동할 수 있는 경우
            elif temp_arr[ny][nx] == 2 and (plant[(ny, nx)][0] + plant[(ny, nx)][1] < day - 4):
                # 오전/ 현재 위치에 씨앗을 심음
                temp_arr[y][x] = 2
                # 심는 씨앗에 심은 날짜와, 그 지역에 심어진 횟수를 기록한다.
                if (y, x) not in plant.keys():
                    plant[(y, x)] = [day, 0]
                elif (y, x) in plant.keys():
                    plant[(y, x)][0] = day
                    plant[(y, x)][1] += 1
                # 오후/ 이동
                DFS(ny, nx, day + 1, nd, cnt)
                return

    # 이동할 수 없는 경우
    else:

        # 현재 농지에 곡식이 열린 경우(arr[y][x] == 2)
        if temp_arr[y][x] == 2:
            # 오전/ 수확
            cnt += 1
            temp_arr[y][x] = 0
            plant[(y, x)][0] = M
            # 오후/ 패스
            DFS(y, x, day + 1, d, cnt)
            return

        # 현재 빈농지일 경우(arr[y][x] == 0)
        if temp_arr[y][x] == 0:
            # 오후/ 패스
            DFS(y, x, day + 1, d, cnt)
            return


move_direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]
head_direction = [0, 1, 2, 3]

T = int(input())
for tc in range(1, T+1):
    result = 0
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    for sy in range(N):
        for sx in range(N):
            if arr[sy][sx] == 0:
                for sd in head_direction:
                    plant = {}
                    temp_arr = deepcopy(arr)
                    DFS(sy, sx, 1, sd, 0)
    print(f'#{tc} {result}')

"""
10
6 11
1 1 1 1 1 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
6 10
1 1 1 1 1 1
1 0 1 0 1 1
1 1 0 1 0 1
1 0 1 0 1 1
1 1 0 1 0 1
1 1 1 1 1 1
7 26
1 1 1 1 1 1 1
1 0 0 0 0 0 1
1 1 0 1 0 0 1
1 0 0 0 0 1 1
1 0 1 0 0 0 1
1 0 0 1 0 0 1
1 1 1 1 1 1 1
7 32
1 1 1 1 1 1 1
1 1 0 0 1 0 1
1 0 1 0 0 0 1
1 0 1 1 0 0 1
1 0 0 1 0 0 1
1 1 0 0 0 1 1
1 1 1 1 1 1 1
7 35
1 1 1 1 1 1 1
1 1 0 0 1 1 1
1 0 0 0 0 0 1
1 1 0 0 1 0 1
1 0 0 1 0 0 1
1 0 1 0 0 1 1
1 1 1 1 1 1 1
8 40
1 1 1 1 1 1 1 1
1 0 0 0 0 0 1 1
1 0 0 1 1 0 1 1
1 0 1 0 1 0 0 1
1 0 0 0 1 0 1 1
1 0 1 1 0 0 0 1
1 1 0 0 0 1 1 1
1 1 1 1 1 1 1 1
8 42
1 1 1 1 1 1 1 1
1 0 0 0 0 1 0 1
1 0 0 1 0 1 0 1
1 1 0 1 0 0 0 1
1 0 0 0 0 0 1 1
1 1 0 1 1 0 1 1
1 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1
9 45
1 1 1 1 1 1 1 1 1
1 0 1 1 1 0 0 1 1
1 0 0 0 1 0 0 0 1
1 0 0 0 1 0 1 1 1
1 1 1 0 1 0 0 0 1
1 1 0 1 1 0 0 1 1
1 1 1 0 1 1 0 0 1
1 0 0 0 0 1 0 0 1
1 1 1 1 1 1 1 1 1
9 48
1 1 1 1 1 1 1 1 1
1 0 1 0 0 0 0 1 1
1 0 1 0 0 0 1 0 1
1 0 1 0 0 0 0 0 1
1 1 0 0 1 0 1 1 1
1 1 0 0 0 1 1 1 1
1 0 0 1 0 1 1 0 1
1 1 1 0 1 1 1 1 1
1 1 1 1 1 1 1 1 1
9 50
1 1 1 1 1 1 1 1 1
1 0 1 1 1 0 0 1 1
1 0 1 0 0 1 0 1 1
1 0 1 0 0 0 0 1 1
1 1 1 0 0 0 0 1 1
1 0 0 1 1 1 1 1 1
1 1 0 0 1 1 0 1 1
1 1 1 1 0 0 1 0 1
1 1 1 1 1 1 1 1 1

#1 4
#2 0
#3 10
#4 11
#5 16
#6 14
#7 20
#8 18
#9 15
#10 22
"""