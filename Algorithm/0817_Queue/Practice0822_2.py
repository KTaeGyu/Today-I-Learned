"""
[Fig. 1] 과 같이 N x N 크기 정사각형 모양의 지형을 가진 행성이 있다.
N x N 크기 지형의 각 칸은 농지와 산 중 하나이다. ( 빈 칸은 농지를 의미하고 산 모양의 칸은 산을 의미한다. )

농지에 씨를 심고 1 일이 지나면 싹이 난다.
그 농지에 대해서 1 번째로 싹이 나는 경우, 싹이 난 후 4 ( = 3 + 1 ) 일 이후에 곡식이 열린다.
그 농지에 대해서 K 번째로 싹이 나는 경우, 싹이 난 후 3 + K 일 이후에 곡식이 열린다. ( K 는 1 이상의 정수 )
지구인들은 이 행성에 로봇 “개척자”를 보내어 곡물을 수확하고자 한다.

로봇은 매일 오전과 오후로 나눠서 다음과 같이 동작한다.
    1) 로봇은 오전에 현재 위치에서 아래의 작업 중 하나를 수행한다.
        - 현재 농지가 빈 농지이고 로봇이 다음 농지로 이동할 수 있는 경우 씨를 심는다.
        - 현재 농지가 빈 농지이고, 로봇이 다음 농지로 이동할 수 없을 경우 아무것도 하지 않고 현재 위치에서 머무른다.
        - 현재 농지에 곡식이 열린 경우 수확을 한다. 수확을 하면 농지는 빈 농지가 된다.
    2) 로봇은 오후에 로봇이 바라보는 방향의 오른쪽, 앞쪽, 왼쪽, 뒤쪽 이웃하는 곳 중, 이동 가능한 곳으로 이동한다.
        - 이동 가능한 곳은 빈 농지, 또는 곡식이 열린 농지이다. 산이거나 싹이 나는 농지인 경우 이동이 불가능하다.
        - 만약, 이동 가능한 곳이 여러 개인 경우, 로봇의 오른쪽, 앞쪽, 왼쪽, 뒤쪽의 순서로 가장 먼저인 이동 가능한 곳으로 이동한다.
        - 만약 이동 가능한 곳이 없는 경우 로봇은 이동하지 않고 현재 위치에 머무른다.
    3) 다음 날이 되면 과정 1) ~ 2) 를 반복한다.

로봇 “개척자” 는 행성에 도착한 날로부터 M 일 까지 동작할 수 있다.
지구인들은 M 일 동안 곡식을 가장 많이 수확할 수 있는 시작 위치와 방향을 알고 싶어한다.

행성의 지형 정보가 주어졌을 때, M 일 동안 “개척자” 로봇이 곡식을 가장 많이 수확할 수 있는 시작 위치와 방향을 찾고,
이때 수확 횟수를 출력하는 프로그램을 작성하라.

[제약사항]
    1. 지형의 한 변의 길이 N 은 6 이상 9 이하의 정수이다. ( 6 ≤ N ≤ 9 )
    2. 로봇이 동작하는 일 수 M 은 10 이상 50 이하의 정수이다. ( 10 ≤ M ≤ 50 )
    3. 지형의 테두리는 언제나 산이다.
    4. 지형 정보에서 0 은 농지, 1 은 산을 의미한다.
    5. 주어지는 지형에는 반드시 농지가 1 개 이상 있다.
    6. 로봇의 시작점은 언제나 농지이어야 한다. 산에서 시작할 수 없다.

입력
입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,
그 다음 줄부터 T 개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 지형의 한 변의 길이 N, 로봇이 동작 가능한 일 수 M 이 주어진다.
다음 N 개의 줄에는 지형 정보가 주어진다. 농지는 0, 산은 1 로 주어진다.

출력
테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )
출력해야 할 정답은, 로봇 "개척자" 의 최대 수확 횟수이다.
"""
import sys
sys.stdin = open("input.txt", "r")


def DFS(y, x, day):
    if day > M:
        return
    for dy, dx in direction:
        ny, nx = y + dy, x + dx
        if arr[ny][nx]
        if 0 <= ny < N and 0 <= nx < N and arr[ny][nx] == 0:
            arr[y][x] = (2, day)
            DFS(y, x, day + 1)
            arr[y][x] = 0
    else:
        DFS(y, x, day + 1)


direction = [(-1, 0), (0, 1), (-1, 0), (0, 1)]
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    max_v = 0
    for y in range(N):
        for x in range(N):
            cnt = 0
            if arr[y][x] == 0:
                DFS(y, x, 1)
            if max_v < cnt:
                max_v = cnt
"""
10
6 11
1 1 1 1 1 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
6 10
1 1 1 1 1 1
1 0 1 0 1 1
1 1 0 1 0 1
1 0 1 0 1 1
1 1 0 1 0 1
1 1 1 1 1 1
7 26
1 1 1 1 1 1 1
1 0 0 0 0 0 1
1 1 0 1 0 0 1
1 0 0 0 0 1 1
1 0 1 0 0 0 1
1 0 0 1 0 0 1
1 1 1 1 1 1 1
7 32
1 1 1 1 1 1 1
1 1 0 0 1 0 1
1 0 1 0 0 0 1
1 0 1 1 0 0 1
1 0 0 1 0 0 1
1 1 0 0 0 1 1
1 1 1 1 1 1 1
7 35
1 1 1 1 1 1 1
1 1 0 0 1 1 1
1 0 0 0 0 0 1
1 1 0 0 1 0 1
1 0 0 1 0 0 1
1 0 1 0 0 1 1
1 1 1 1 1 1 1
8 40
1 1 1 1 1 1 1 1
1 0 0 0 0 0 1 1
1 0 0 1 1 0 1 1
1 0 1 0 1 0 0 1
1 0 0 0 1 0 1 1
1 0 1 1 0 0 0 1
1 1 0 0 0 1 1 1
1 1 1 1 1 1 1 1
8 42
1 1 1 1 1 1 1 1
1 0 0 0 0 1 0 1
1 0 0 1 0 1 0 1
1 1 0 1 0 0 0 1
1 0 0 0 0 0 1 1
1 1 0 1 1 0 1 1
1 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1
9 45
1 1 1 1 1 1 1 1 1
1 0 1 1 1 0 0 1 1
1 0 0 0 1 0 0 0 1
1 0 0 0 1 0 1 1 1
1 1 1 0 1 0 0 0 1
1 1 0 1 1 0 0 1 1
1 1 1 0 1 1 0 0 1
1 0 0 0 0 1 0 0 1
1 1 1 1 1 1 1 1 1
9 48
1 1 1 1 1 1 1 1 1
1 0 1 0 0 0 0 1 1
1 0 1 0 0 0 1 0 1
1 0 1 0 0 0 0 0 1
1 1 0 0 1 0 1 1 1
1 1 0 0 0 1 1 1 1
1 0 0 1 0 1 1 0 1
1 1 1 0 1 1 1 1 1
1 1 1 1 1 1 1 1 1
9 50
1 1 1 1 1 1 1 1 1
1 0 1 1 1 0 0 1 1
1 0 1 0 0 1 0 1 1
1 0 1 0 0 0 0 1 1
1 1 1 0 0 0 0 1 1
1 0 0 1 1 1 1 1 1
1 1 0 0 1 1 0 1 1
1 1 1 1 0 0 1 0 1
1 1 1 1 1 1 1 1 1

#1 4
#2 0
#3 10
#4 11
#5 16
#6 14
#7 20
#8 18
#9 15
#10 22
"""